Randomization Guide – How to Achieve BalanceAuthors: Martin Sweeney (updated by Matt White and Kelsey Larson)
Date: October 15, 2013 (updated July 27, 2018)  Code for 3. Many Stratification Variables updated by Muskan Aggarwal on Jan 21st, 2024General Randomization TipsAn error in randomization coding can badly harm the quality of a randomized control trial – the presumption of random assignment is the most important presumption that RCT analysis makes. So when coding a randomization, you should:Use prewritten commands when possible.
You can do this type of randomization with the randtreat program located on the IPA GitHub (not available on GitHub anymore; check here). Randtreat can handle most types of randomization commonly used by GPRL. Working with an established program can help reduce the risk of coding errors, so please use randtreat unless you have an extraordinary circumstance that makes using the program impossible.
Use the “assert” and “confirm” commands liberally.
When doing a randomization, check each step to make sure the code is producing exactly what you wanted. “Assert” and “confirm” will throw an error if the code ever breaks your checks. For example, if a section of code was supposed to assign exactly 50 people to the treatment group, you might end the section with:  

count if treatment == 1
assert `r(N)' == 50 // the treatment group should contain exactly 50 people at this stage.

When you’ve written the randomization, try running it a few hundred times with different seeds and compare the outcomes.
In most randomizations, all of the units randomized should have an approximately similar chance of being assigned into the treatment and control group. For example, if 30% of the sample will be assigned to treatment, each observation should be assigned to the treatment group in approximately 30% of the randomizations you run. Try rerunning the treatment assignment, creating a variable that is the mean of randomization 1-500 for each observation, and graph it with a simple hist avg_treat_assignment. If that histogram does not look like a binomial distribution – if some observations are almost always in treatment or almost always in control – you should check your randomization code to see if something is going wrong.

Types of RandomizationEconomists debate the best methods for randomization, so it’s good to be familiar with some of the different methods your PIs might consider. Chapter 4 of Running Randomized Evaluations: A Practical Guide by Glennerster and Takavarasha gives an in-depth discussion of randomization design. As a broad overview, several of the main types of randomization are:• Simple randomization
  Each unit has an equal and independently assigned probability of being assigned to each treatment arm. To implement this, generate a random number, sort by that number, and then assign the first n observations to treatment and the rest to control.  Pros: This type of randomization is “truly random.” Econometrically, this allows very strong assumptions of randomness to be made in analysis.
  Cons: There’s a risk that the randomly sorted groups will differ substantially along important characteristics, undermining the study’s ability to attribute changes to treatment. This is almost never used unless we lack baseline data.• Stratified randomization
  The sample is split into strata defined by important variables, and we randomize within each stratum.  Pros: Enforces balance along key variables. Transparent, easy to explain, works well with randomization inference. Widely accepted.
  Cons: Requires binning continuous variables. Can only handle a limited number of variables (to keep strata large enough). Need to handle odd-sized strata.• Cluster randomization
  Randomization at the group level (e.g., schools, villages).  Pros: Avoids spillovers; often easier logistically.
  Cons: Reduces statistical power → need larger sample or accept less precision.• Clustered and Stratified Randomization
  Combines both approaches.• Rerandomization
  Run your randomization 10,000+ times, test each for balance, and keep the most balanced one.  Pros: Achieves excellent balance on many variables. Leads to tighter standard errors and reviewer-friendly balance tables.
  Cons: Complicates randomization inference. May skew assignment probabilities for some units. Always check that no unit is systematically favored (use Tip #3).The Rerandomization TechniqueThis guide highlights a method featured in Bruhn & McKenzie (2009) that is widely used by GPRL.Instead of accepting a single “good enough” randomization, we run thousands (10,000–100,000) and select the one with the best balance (highest p-value or highest minimum p-value across multiple variables).Important: Rerandomization can break the assumptions needed for randomization inference. If PIs want to use RI, prefer simple stratified randomization.First choice: Use the randtreat command — it’s battle-tested and does rerandomization automatically.If you must write it yourself, here are three fully working Stata examples:1. One continuous balance variable (maximize p-value)stata

// stratifies on: highaccess, marketed2013 
// balances on: compcount 

isid Communi2                        // assert unique ID
sort Communi2                        // sort on unique ID
version 12.1: set seed 528713  
gen double rand = .                  
gen double rand2 = . 
gen treatment_num = .
gen besttreatment_num = .
loc p 0                              
loc bestp 0 

quietly forv x=1/10000 { 
    sort Communi2  
    replace rand = runiform() 
    replace rand2 = runiform() 
    isid rand rand2                  // assert no duplicates
    sort highaccess marketed2013 rand rand2 

    by highaccess marketed2013 (rand rand2): ///
    replace treatment_num = ///
        cond(_n <  .32*_N, 1, ///
        cond(_n >= .32*_N & _n < .51*_N, 2, ///
        cond(_n >= .51*_N & _n < .70*_N, 3, ///
        cond(_n >= .70*_N & _n <= _N, 4, .))))

    // Test balance
    reg compcount i.treatment_num 
    testparm i.treatment_num 
    loc p = r(p) 

    if `p' > `bestp' {  
        loc bestp = `p'  
        replace besttreatment_num = treatment_num 
    } 
    noisily display `x' 
}
display "Best p-value: `bestp'"
// Final assignments in besttreatment_num

2. Multiple continuous variables (maximize the minimum p-value)stata

// stratifies on: highaccess, marketed2013 
// balances on: compcount, hhsize_av  

isid Communi2  
sort Communi2  
version 12.1: set seed 528713  
gen double rand = .  
gen double rand2 = . 
gen treatment_num = .
gen mintreatment_num = .
loc p1 0 
loc p2 0 
loc minp 0 
loc minp1 0 
loc minp2 0 

quietly forv x=1/10000 { 
    sort Communi2  
    replace rand = runiform() 
    replace rand2 = runiform() 
    isid rand rand2  
    sort highaccess marketed2013 rand rand2 

    by highaccess marketed2013 (rand rand2): ///
    replace treatment_num = ///
        cond(_n <  .32*_N, 1, ///
        cond(_n >= .32*_N & _n < .51*_N, 2, ///
        cond(_n >= .51*_N & _n < .70*_N, 3, ///
        cond(_n >= .70*_N & _n <= _N, 4, .))))

    reg compcount i.treatment_num 
    testparm i.treatment_num 
    loc p1 = r(p) 

    reg hhsize_av i.treatment_num 
    testparm i.treatment_num 
    loc p2 = r(p) 

    if min(`p1', `p2') > `minp' { 
        loc minp1 = `p1' 
        loc minp2 = `p2' 
        loc minp = min(`minp1', `minp2') 
        replace mintreatment_num = treatment_num 
    } 
    noisily display `x' 
}
display "p1: `minp1'" 
display "p2: `minp2'"

3. Many strata + uneven cell sizes (equal-sized treatment groups)stata

// Example: 3 arms (0=control, 1=T1, 2=T2), 60 strata
egen strata = group(access c4d_treatment_num low_behavior low_knowledge) 
tab strata, missing   // 60 strata

gen m4d_treatment = .
gen best_treatment = .
loc minp 0

quietly forv x = 1/10000 {
    sort household_id
    gen rand  = runiform()
    gen rand2 = runiform()
    isid rand rand2
    sort strata rand rand2

    foreach q of numlist 1/60 {
        loc assign = floor(runiform()*100000)
        by strata (rand rand2): replace m4d_treatment = mod(`assign',3)     if strata==`q' & _n <= _N/3
        by strata (rand rand2): replace m4d_treatment = mod(`assign'+1,3) if strata==`q' & _n > _N/3 & _n <= 2*_N/3
        by strata (rand rand2): replace m4d_treatment = mod(`assign'+2,3) if strata==`q' & _n > 2*_N/3
    }

    // Balance checks (example)
    reg compcount i.m4d_treatment
    testparm i.m4d_treatment
    loc p1 = r(p)
    reg hhsize_av i.m4d_treatment
    testparm i.m4d_treatment
    loc p2 = r(p)

    if min(`p1',`p2') > `minp' {
        loc minp = min(`p1',`p2')
        replace best_treatment = m4d_treatment
    }
    noisily display `x'
}

This method ensures perfectly equal group sizes even when strata sizes aren’t divisible by 3.ReferencesBruhn, Miriam, and David McKenzie. 2009. "In Pursuit of Balance: Randomization in Practice in Development Field Experiments" American Economic Journal: Applied Economics, 1(4): 200–232.

